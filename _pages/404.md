---
title: "Page Not Found"
sitemap: false
permalink: /404.html
# layout: default
# title: "404: Page Not Found"
# show_toc: true
---
## 404: Page Not Found
Oh,no...
Sorry, but the page you were trying to view does not exist. But why?
You can try the following solutions:

- Check the URL for typos or mistakes.
- Click [Harudog](https://harudogmyland.github.io/) back to homepage...
- Use the search function to find the page you are looking for. (Do I have it?)

Anyway if you still need help, feel free to contact me at [this address](https://www.bilibili.com/video/BV1UT42167xb?t=2.0)

---

<!-- 见缝插针 游戏 - 直接粘入 Markdown 网页 -->
<div id="needle-game" style="max-width:420px;margin:18px auto;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;">
  <style>
    #needle-game .panel { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
    #needle-game button { padding:6px 10px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    #needle-game .score { font-weight:600; }
    #needle-game canvas { display:block; width:100%; height:auto; background:#111; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,.45); }
    #needle-game .hint { margin-top:8px; color:#666; font-size:13px; }
  </style>

  <div class="panel">
    <div>
      <strong>见缝插针</strong>
      <div style="font-size:12px;color:#666;">点击 / 触摸 / 空格 — 插针</div>
    </div>
    <div style="text-align:right">
      <div class="score">分数: <span id="score">0</span></div>
      <div style="font-size:12px;color:#666">关卡: <span id="level">1</span></div>
    </div>
  </div>

  <canvas id="canvas" width="420" height="560"></canvas>

  <div style="display:flex;gap:8px;margin-top:8px;">
    <button id="startBtn">开始</button>
    <button id="pauseBtn">暂停</button>
    <button id="restartBtn">重新开始</button>
  </div>

  <div class="hint">
    笑死，根本运行不了
  </div>
</div>

<script>
(function(){
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  // logical size (keeps crisp on high-DPI)
  const W = 420, H = 560;
  canvas.width = W; canvas.height = H;

  const center = { x: W/2, y: H/3 }; // 圆心偏上
  let radius = Math.min(W, H) * 0.22; // 主盘半径
  const needleLen = radius * 1.05; // 插入针到圆心外一点
  const needleThickness = 6;

  // Game state
  let running = false;
  let paused = false;
  let score = 0;
  let level = 1;
  let pins = []; // 已固定在盘上的针，记录 angle (弧度)
  let rotation = 0; // 当前圆盘旋转角度（弧度）
  let rotationSpeed = 0.02; // 每帧旋转增量（弧度）
  let pendingNeedle = null; // 正在发射的针（如果有）
  let maxPinsToLevel = 6;
  let lastTime = null;
  let animationId = null;

  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');

  // Utils
  function rand(min, max){ return Math.random()*(max-min)+min; }
  function angleDiff(a, b){
    // 返回两个角度差的最小绝对值（弧度）
    let d = Math.abs(a-b) % (Math.PI*2);
    return d > Math.PI ? (Math.PI*2 - d) : d;
  }

  // Input: 插针（发射）
  function launchNeedle(){
    if (!running || paused) return;
    if (pendingNeedle) return; // 只允许一针同时发射
    pendingNeedle = {
      x: center.x,
      y: H - 30, // 从画布底部发射
      vx: 0,
      vy: -10 - level*1.2, // 发射速度，随等级增加
      attached: false
    };
  }

  // 检测碰撞：当 pendingNeedle 接触圆盘区域时判断角度是否冲突
  function tryAttach(needle){
    // 计算针头触碰到圆盘边缘时所在的角度（相对于圆心）
    const dx = needle.x - center.x;
    const dy = needle.y - center.y;
    const dist = Math.hypot(dx, dy);
    if (dist > radius - 6 && dist < radius + 10) {
      let angle = Math.atan2(dy, dx) - rotation; // 将当前旋转值去除，得到相对角度
      // 归一化到 -PI..PI
      if (angle > Math.PI) angle -= Math.PI*2;
      if (angle < -Math.PI) angle += Math.PI*2;

      // 碰撞阈值：针头之间角度间隔不足判定为碰撞
      const minAngleBetween = (needleThickness*1.4) / radius; // 依据大小动态计算阈值
      for (let a of pins){
        if (angleDiff(a, angle) < minAngleBetween) {
          return { success:false, angle };
        }
      }
      return { success:true, angle };
    }
    return null; // 还没接触
  }

  // Attach newly inserted needle at angle (relative to disk) — store in pins
  function attachAt(angleRel){
    // 存储标准化的角度（-PI..PI）
    let a = angleRel;
    if (a > Math.PI) a -= Math.PI*2;
    if (a < -Math.PI) a += Math.PI*2;
    pins.push(a);
    score += 1;
    scoreEl.textContent = score;
    // 每插入 maxPinsToLevel 支进入下一关
    if (pins.length % maxPinsToLevel === 0){
      level += 1;
      levelEl.textContent = level;
      // 提高转速和发射难度
      rotationSpeed *= 1.18;
    }
  }

  // Game over
  function gameOver(){
    running = false;
    pendingNeedle = null;
    cancelAnimationFrame(animationId);
    animationId = null;
    setTimeout(()=> {
      // 使用浏览器友好提示（不打断渲染）
      if (confirm('游戏结束！分数: ' + score + '，是否重新开始？')) {
        resetGame();
        start();
      }
    }, 80);
  }

  // Reset
  function resetGame(){
    pins = [];
    rotation = 0;
    rotationSpeed = 0.02 + (Math.random()*0.01);
    score = 0;
    level = 1;
    pendingNeedle = null;
    scoreEl.textContent = score;
    levelEl.textContent = level;
  }

  // Draw functions
  function drawDisk(){
    // 外圈
    ctx.save();
    ctx.translate(center.x, center.y);
    ctx.rotate(rotation);
    // 主盘
    const grd = ctx.createRadialGradient(-radius/3, -radius/3, radius*0.1, 0, 0, radius);
    grd.addColorStop(0, '#2b2b2b');
    grd.addColorStop(1, '#111');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, radius, 0, Math.PI*2);
    ctx.fill();

    // 中心小圆
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.arc(0, 0, radius*0.26, 0, Math.PI*2);
    ctx.fill();

    // 装饰圈（刻度）
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    for (let i=0;i<12;i++){
      ctx.beginPath();
      ctx.moveTo( (radius+6)*Math.cos(i*Math.PI*2/12), (radius+6)*Math.sin(i*Math.PI*2/12));
      ctx.lineTo( (radius+14)*Math.cos(i*Math.PI*2/12), (radius+14)*Math.sin(i*Math.PI*2/12));
      ctx.stroke();
    }
    // 固定在盘上的针（相对于盘的角度）
    for (let a of pins){
      drawPinOnDisk(a);
    }
    ctx.restore();
  }

  function drawPinOnDisk(angleRel){
    // angleRel is relative to disk (not including rotation)
    const a = angleRel + rotation;
    const x = center.x + Math.cos(a) * (radius + 2);
    const y = center.y + Math.sin(a) * (radius + 2);

    // draw pin as rectangle pointing outward
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(a);
    ctx.fillStyle = '#eee';
    ctx.fillRect(-needleThickness/2, -6, needleThickness, needleLen*0.18); // short visible shaft
    // pin head
    ctx.beginPath();
    ctx.arc(0, -6, needleThickness*0.8, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawPending(needle){
    // draw shaft from bottom to needle.y, with head
    ctx.save();
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = needleThickness;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(needle.x, H);
    ctx.lineTo(needle.x, needle.y);
    ctx.stroke();

    // head
    ctx.beginPath();
    ctx.arc(needle.x, needle.y-needleThickness/2, needleThickness*0.9, 0, Math.PI*2);
    ctx.fillStyle = '#ddd';
    ctx.fill();
    ctx.restore();
  }

  function render(){
    // clear
    ctx.fillStyle = '#0c0c0c';
    ctx.fillRect(0,0,W,H);

    // draw disk and pins
    drawDisk();

    // draw base (where player stands / launcher)
    ctx.save();
    ctx.translate(W/2, H-20);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(-80, 8, 160, 10);
    ctx.restore();

    // draw pending needle if any
    if (pendingNeedle) drawPending(pendingNeedle);
  }

  // Main loop
  function loop(ts){
    if (!lastTime) lastTime = ts;
    const dt = ts - lastTime;
    lastTime = ts;

    if (!paused && running){
      // rotate disk
      rotation += rotationSpeed * (dt/16.6667); // make speed frame-time independent
      // clamp rotation
      rotation %= Math.PI*2;

      // update pending needle
      if (pendingNeedle){
        pendingNeedle.y += pendingNeedle.vy; // vy is negative (moving up)
        // Check if touches disk region
        const check = tryAttach(pendingNeedle);
        if (check){
          if (!check.success){
            // collision -> game over
            pendingNeedle = null;
            render(); // final frame
            gameOver();
            return;
          } else {
            // attach
            attachAt(check.angle);
            pendingNeedle = null;
          }
        } else {
          // out of bounds (missed?), if y < -50 then game over (unlikely)
          if (pendingNeedle.y < -60) {
            pendingNeedle = null;
            // treat as miss -> game over
            gameOver();
            return;
          }
        }
      }
    }

    render();
    animationId = requestAnimationFrame(loop);
  }

  // Start / Pause / Stop control
  function start(){
    if (running) return;
    running = true;
    paused = false;
    lastTime = null;
    if (!animationId) animationId = requestAnimationFrame(loop);
  }
  function pause(){
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? '继续' : '暂停';
  }
  function restart(){
    resetGame();
    start();
  }

  // Initial visuals
  resetGame();
  render();

  // Events
  startBtn.addEventListener('click', ()=> start());
  pauseBtn.addEventListener('click', ()=> pause());
  restartBtn.addEventListener('click', ()=> {
    resetGame();
    render();
  });

  // Mouse / touch / keyboard
  canvas.addEventListener('click', ()=> launchNeedle());
  canvas.addEventListener('touchstart', (e)=>{
    e.preventDefault();
    launchNeedle();
  }, {passive:false});
  window.addEventListener('keydown', (e)=> {
    if (e.code === 'Space') {
      e.preventDefault();
      launchNeedle();
    } else if (e.code === 'KeyP') {
      pause();
    }
  });

  // auto-start for convenience
  // start();

  // expose for debugging (optional)
  window._needleGame = {
    launch: launchNeedle,
    start, pause, restart,
    getState: ()=>({running, paused, score, level, pins: pins.slice()})
  };
})();
</script>
